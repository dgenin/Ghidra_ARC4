define token instr(32)
	iI    = (27, 31) # opcode
	iA    = (21, 26) # destination reg
	iBL_L = (7,26) signed  # destination address divided by 4
	iST_Di= (26, 26) # direct (cache bypass)
	iST_0 = (25, 25)
	iST_A = (24, 24) # address write-back enable
	iST_Z = (22, 23) # size field used by ST
	iA_alias  = (21, 26) # necessary because iA cannot occur as both parameter and constraint at once
	iB        = (15, 20) # op 1 address
	iB_alias  = (15, 20)
	iSR_B	  = (15, 20)
	iC        = (9, 14) # op 2 address
	iC_alias  = (9, 14)
	iLD0_R    = (13, 13) # reserved should be 0
	iLD1_R    = (6, 8)
	iLD0_Di   = (14, 14)  # direct (cache bypass)
	iLD1_Di   = (5, 5)
	iLD1_A    = (12, 12) # address write-back enable (see ARC Ref. p. 99)
	iLD1_Z    = (1, 2)
	iLD0_Z    = (10, 11) # size field used by LD
	iLD0_X    = (9, 9)   # sign extend field
	iLD1_X    = (0, 0)
	iF   	  = (8, 8) # flags set field
	iR   	  = (7, 7) # reserved, must be 0
	iN   	  = (5, 6) # jump/call nullify instruction mode
	iQ   	  = (0, 4) # condition flags
	iD   	  = (0, 8) # short immediate data
	iLD0_A 	  = (3,3) # address write-back enable for instruction without short immediate (see ARC Ref. p.100)
	iSR_D = (0, 5); # special register index for SR, note that this should
					# actually be (0, 8) but this would require making
					# the special register file 2^9 long.
define token limm_token(32)
       limm32_field = (0,31);

attach names iQ [
       AL EQ NE PL MI CS CC VS VC GT GE LT LE HI LS PNZ ex0
       ex1 ex2 ex3 ex4 ex5 ex6 ex7 ex8 ex9 exA exB exC exD exE exF
       ];

attach variables [ iA iB iC ] [
       r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14
       r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 fp sp
       ilink1 ilink2 blink
       ext0  ext1  ext2  ext3  ext4  ext5  ext6  ext7  ext8  ext9  ext10 ext11 ext12 ext13 ext14
       ext15 ext16 ext17 ext18 ext19 ext20 ext21 ext22 ext23 ext24 ext25 ext26 ext27 lp_count
       shimmflags limm shimmnoflags
];

attach variables [ iSR_D iSR_B ] [
	status semaphore lp_start lp_end identity debug
	aux6 aux7 aux8 aux9 aux10 aux11 aux12 aux13 aux14 aux15
	aux16 aux17 aux18 aux19 aux20 aux21 aux22 aux23 aux24 aux25
	aux26 aux27 aux28 aux29 aux30 aux31
	aux32 aux33 aux34 aux35
	aux36 aux37 aux38 aux39 aux40 aux41 aux42 aux43 aux44 aux45
	aux46 aux47 aux48 aux49 aux50 aux51 aux52 aux53 aux54 aux55
	aux56 aux57 aux58 aux59 aux60 aux61
	aux62 aux63
];

# p.61 of ARC Ref. regs 61-63 reserved for encoding immediate data

# 61 - Short immediate data indicator setting
#      flags
# 62 - Long immediate data indicator
# 63 - Short immediate data indicator not setting
#      flags

opA1: iA is iA_alias<61 & iA { export iA; } # normal register operand
opA1: "0" is iA_alias=61 & iA { export iA; } # short immediate with flags set
opA1: "0" is iA_alias>61 & iA { export iA; } # short immediate without flags set or long immediate flags?
# NOTEL: No long immediate for opA1 because it is the destination register. Short immediate for opA1
# 	 is used for setting flags only.

opB1: iB is iB_alias<61 & iB { export iB; } # normal register operand
opB1: iD is iB=61 & iD { export *[const]:$(SIZE) iD; } # short immediate with flags set
opB1: iD is iB=63 & iD { export *[const]:$(SIZE) iD; } # short immediate without flags set
opB1: limm32_field is iB_alias=62 & iB_alias; limm32_field { export *[const]:$(SIZE) limm32_field; } # long immediate

# TODO: SR instruction with implicit register specification, e.g.,
#		sr r1, [r2]
#		results in decompiler code with a RAM memory write, e.g.,
#		*(int **)((uVar1 & 0x3f) + 0x1300) = piParm2;
opSR_B1: iSR_B is iB_alias<61 & iSR_B { export iSR_B; } # normal register operand
opSR_B1: iSR_D is iSR_B=61 & iSR_D { export iSR_D; } # short immediate with flags set
opSR_B1: iSR_D is iSR_B=63 & iSR_D { export iSR_D; } # short immediate without flags set
opSR_B1: limm32_field is iB_alias=62 & iB_alias; limm32_field { export *[const]:$(SIZE) limm32_field; } # long immediate

opC1: iC is iC_alias<61 & iC { export iC; } # normal register operand
opC1: iD is iC=61 & iD { export *[const]:$(SIZE) iD; } # short immediate with flags set
opC1: iD is iC=63 & iD { export *[const]:$(SIZE) iD; } # short immediate without flags set
opC1: limm32_field is iC=62; limm32_field { export *[const]:$(SIZE) limm32_field; } # long immediate

cc: "" is iQ=0 { export 1:1; } #not displaying anything for always-execute
cc: ".eq" is iQ=1 { export Z; }
cc: ".ne" is iQ=2 { tmp:1 = !Z; export tmp; }
cc: ".pl" is iQ=3 { tmp:1 = !N; export tmp; }
cc: ".mi" is iQ=4 { export N; }
cc: ".cs" is iQ=5 { export C; }
cc: ".cc" is iQ=6 { tmp:1 = !C; export tmp; }
cc: ".vs" is iQ=7 { export V; }
cc: ".vc" is iQ=8 { tmp:1 = !V; export tmp; }
cc: ".gt" is iQ=9 { tmp:1 = (!Z) && (N==V); export tmp; }
cc: ".ge" is iQ=10 { tmp:1 = (N==V); export tmp; }
cc: ".lt" is iQ=11 { tmp:1 = (N!=V); export tmp; }
cc: ".le" is iQ=12 { tmp:1 = Z || (N!=V); export tmp; }
cc: ".hi" is iQ=13 { tmp:1 = C && (!Z); export tmp; }
cc: ".ls" is iQ=14 { tmp:1 = (!C) || Z; export tmp; }
cc: ".pnz" is iQ=15 { tmp:1 = (!Z) && (!N); export tmp; }

COND: cc is cc & (iQ=0 & iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
COND: cc is cc & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { if (!cc) goto inst_next; }
# Always execute
COND: "" is ((iC > 60 & iC != 62) | (iB > 60 & iB != 62)) { } #(iC=61 | iC=63 | iB=61 | iB=63) { }

LP_COND: cc is cc & (iQ=0 & iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
LP_COND: cc is cc & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { if (cc) goto <skip>; goto [lp_addr]; <skip> }
# Always execute
LP_COND: "" is ((iC > 60 & iC != 62) | (iB > 60 & iB != 62)) { } #(iC=61 | iC=63 | iB=61 | iB=63) { }


# TODO: Try jumps with short immediate data which is not documented in the specification.
# 	Doesn't seem to be possible to force assembler to produce a jump with a short immediate

# Doesn't work because table values (opB1) are not allowed in square brackets.
# JADDR: reloc is opB1 [ reloc = (opB1 & 0xFFFFFF) << 2; ] { export *[ram]:4 reloc; }

# JADDR: byte_addr is iB_alias<61 & iB { export iB; } # normal register operand
# JADDR: byte_addr is iB=61 & iD { export *[const]:$(SIZE) iD; } # short immediate with flags set
# JADDR: byte_addr is iB=63 & iD { export *[const]:$(SIZE) iD; } # short immediate without flags set
JADDR: byte_addr is iB_alias=62 & iB_alias; limm32_field [ byte_addr = (limm32_field & 0xFFFFFF) <<2; ] { export *[ram]:4 byte_addr; } # long immediate


ADDR: reloc is iBL_L [ reloc = inst_next + (4*iBL_L); ] { export *[ram]:4 reloc; }
# Computes address of one instruction before the last instruction named the loop instruction
# to restrict loop branching p-code to only the final instruction in the loop.
# This avoids Ghidra complaining about unreachable blocks if end-of-loop testing
# p-code is inserted into every instruction, which is how hardware does it.
PREV_ADDR: reloc is iBL_L [ reloc = inst_next + (4*iBL_L) - 4; ] { export *[ram]:$(SIZE) reloc; }

PREV_opC1: res is iC_alias<61 & iC [ res = (iC<<2) - 4; ] { export res; } # normal register operand
PREV_opC1: res is iC=61 & iD [ res = (iD<<2) - 4; ] { export *[const]:$(SIZE) res; } # short immediate with flags set
PREV_opC1: res is iC=63 & iD [ res = (iD<<2) - 4; ] { export *[const]:$(SIZE) res; } # short immediate without flags set
PREV_opC1: res is iC=62; limm32_field [ res = (limm32_field<<2) - 4; ]{ export *[const]:$(SIZE) res; } # long immediate

dd: ".nd" is iN=0 { } # TODO: Only execute next instruction when not jumping (Default)
dd: ".d"  is iN=1 { delayslot(1); } # Always execute next instruction
dd: ".jd" is iN=2 { delayslot(1); } # TODO: Only execute next instruction when jumping

# NOTE: This is used only for jl with long immediate address, which occupies
# 	the delay slot. According to the ARC4 spec .jd nullify mode must be
#	used (p. 97).
jl_dd: ".jd" is iN=2 { }

# p.36 ARC4 CPU manual
# Adds end-of-loop p-code test to the last instruction in the loop,
# which is the only instruction for which lp_in_use is 1.
LOOP: is (lp_in_use=0) {}
LOOP: is (lp_in_use=1)
{
	# if next instruction is not the end of the loop do nothing
	if (inst_next!=lp_end) goto <skip>;
	# if next instruction is the end of the loop
	# decrement lp_count
	lp_count = lp_count - 1;
	# if lp_count is 0 do nothing
	if (lp_count==0) goto <skip>;
	# otherwise return to the start of the loop
	goto [lp_start];
<skip>
}

macro resultflags(result) {
 tmpN = result s< 0;
 tmpZ = result == 0;
}

macro addflags(op1,op2) {
 tmpC = carry(op1,op2);
 tmpV = scarry(op1,op2);
}

# NOTE:  unlike x86,  carry flag is SET if there is NO borrow
macro subflags(op1,op2) {
 tmpC = op2 <= op1;
 tmpV = sborrow(op1,op2);
}

FLAGS: ".f" is iF=1 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { C = tmpC; Z = tmpZ; N = tmpN; V = tmpV; }
FLAGS: ""   is iF=0 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
FLAGS: ".f" is (iC<63 & iB<63) { C = tmpC; Z = tmpZ; N = tmpN; V = tmpV; }
FLAGS: ""   is (iC=63 | iB=63) { }

FLAGSNZ: ".f" is iF=1 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { N = tmpN; Z = tmpZ; }
FLAGSNZ: ""   is iF=0 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
FLAGSNZ: ".f" is (iC<63 & iB<63) { N = tmpN; Z = tmpZ; }
FLAGSNZ: ""   is (iC=63 | iB=63) { }

ADDRESS_WRITEBACK0: ".a" is iLD0_A=1 ... & opB1 & opC1 { opB1 = opB1 + opC1; }
ADDRESS_WRITEBACK0: "" is iLD0_A=0 {}
ADDRESS_WRITEBACK1: ".a" is iLD1_A=1 ... & opB1 & iD ... { opB1 = opB1 + iD; }
ADDRESS_WRITEBACK1: "" is iLD1_A=0 {}
# p. 93 of ARC Ref
# TODO: implement write-back and cache bypass and sign extend
# NOTE: ld instruction family does not set status flags see p.100
# LD instructions below use

:ld^ADDRESS_WRITEBACK0 opA1, "["^opB1, opC1^"]" is LOOP & ADDRESS_WRITEBACK0 & (iI=0x0 & iLD1_Z=0x0 & iLD1_R=0x0) ... & opA1 ... & opB1 & opC1 ...
{
	local addr = opB1 + opC1;
	result = *:4 addr;
	opA1 = result;
	build ADDRESS_WRITEBACK0;
}

:ldb^ADDRESS_WRITEBACK0 opA1, "["^opB1, opC1^"]" is LOOP & ADDRESS_WRITEBACK0 & (iI=0x0 & iLD1_Z=0x1 & iLD1_R=0x0) ... & opA1 ... & opB1 & opC1 ...
{
	local addr = opB1 + opC1;
	result = *:1 addr;
	opA1 = zext(result);
	build ADDRESS_WRITEBACK0;
}

:ldw^ADDRESS_WRITEBACK0 opA1, "["^opB1, opC1^"]" is LOOP & ADDRESS_WRITEBACK0 & (iI=0x0 & iLD1_Z=0x2 & iLD1_R=0x0)  ... & opA1 ... & opB1 & opC1 ...
{
	local addr = opB1 + opC1;
	result = *:2 addr;
	opA1 = zext(result);
	build ADDRESS_WRITEBACK0;
}
# LD instructions below use short immediate addressing, e.g., ld r1,[r2,4]
:ld^ADDRESS_WRITEBACK1 opA1, "["^opB1, iD^"]" is LOOP & ADDRESS_WRITEBACK1 & (iI=0x1 & iLD0_Z=0x0 & iLD0_R=0) ... & opA1 ... & opB1 & iD ...
{
	local addr = opB1 + iD;
	result = *:4 addr;
	opA1 = result;
	build ADDRESS_WRITEBACK1;
}

:ldb^ADDRESS_WRITEBACK1 opA1, "["^opB1, iD^"]" is LOOP & ADDRESS_WRITEBACK1 & (iI=0x1 & iLD0_Z=0x1 & iLD0_R=0) ... & opA1 ... & opB1 & iD ...
{
	local addr = opB1 + iD;
	result = *:1 addr;
	opA1 = zext(result);
	build ADDRESS_WRITEBACK1;
}

:ldw^ADDRESS_WRITEBACK1 opA1, "["^opB1, iD^"]" is LOOP & ADDRESS_WRITEBACK1 & (iI=0x1 & iLD0_Z=0x2 & iLD0_R=0)  ... & opA1 ... & opB1 & iD ...
{
	local addr = opB1 + iD;
	result = *:2 addr;
	opA1 = zext(result);
	build ADDRESS_WRITEBACK1;
}

:lr opA1, "["^opB1^"]" is LOOP & (iI=0x1 & iC=0x10) ... & opA1 ... & opB1 & iD ...
{
	local addr = &:2 status + opB1:2;
	reg_val = *[register] addr;
	opA1 = reg_val;
}

# lp_end = 3
# NOTE: Zero-overhead loop setup with explicit stores to auxiliary registers cannot
# 	be made to work with existing implementation. The reason is that it requires
#	constants propagation for the disassembler to be able to insert p-code
#	jump at the correct instruction. The address of the loop end instruction
#	must be computed from the corresponding label (using left shift?), which
#	means it cannot be explicitly computed at compile time by assembler and
#	therefore cannot be an immediate. So loop_end setup requires a register
#	store, e.g., sr r1, [lp_end], where r1 holds the computed address of the
#	end of the loop.
#	The lp instruction circumvents this issue by using pc-relative addressing,
#	so that the loop end instruction address can be computed by the disassembler.
#	lp instruction therefore behaves like a branch instruction.
#
#	Unrelated, the gcc ARC4 assembler appears to OR short immediates in auxiliary
#	register store instructions, making it impossible to use code like
#	sr 0x8e, [lp_end], which assembles into sr 0x8f, [0x8f]. It should have been
#	assembled into an instruction using a short immediate and a long immediate,
#	instead the two immediates are ORed into the short immediate field. Brilliant!
#
# NOTE: opC1 is not allowed in square brackets so we need to make
#		equivalents of ADDR and PREV_ADDR to get the right values in to
#		square brackets.
:sr opC1, "["^opB1^"]" is PREV_opC1 & LOOP & (iI=0x2 & iA=0x10 & (iB=61 | iB=63) & iD=0x3) ... & opC1 ... & opB1 ... & iD ...
[
	# Set lp_in_use context variable for the last
	# instrution at the end of the loop so that
	# the end-of-loop check is performed only
	# in that instruction.
	# NOTE: if lp_end is overwritten while the
	# loop is running there will be sadness:'(
	# lp_in_use=1;
	# globalset(inst_next, lp_in_use);
	# lp_in_use=0;
	# TODO: This still results in unreachable branches because register value
	#		is not known at decompile time and lp_in_use ends up being set
	#		everywhere.
	lp_in_use=1;
	globalset(PREV_opC1, lp_in_use);
	lp_in_use=0;
	globalset(opC1, lp_in_use);
]
{
	lp_end = opC1<<2;
}

:sr opC1, "["^opB1^"]" is LOOP & (iI=0x2 & iA=0x10 & iD!=0x3) ... & opC1 ... & opB1 ... & iD ...
{
	*[register] (&:2 status + opB1:2)  = opC1;
}

:st opC1, "["^opB1, iD^"]" is LOOP & (iI=0x2 & iST_Z=0x0 & iST_0=0) ... & opB1 ... & opC1 & iD ...
{
	local addr = opB1 + iD;
	*:4 addr = opC1:4;
}

:stb opC1, "["^opB1, iD^"]" is LOOP & (iI=0x2  & iST_Z=0x1 & iST_0=0)... & opB1 ... & opC1 & iD ...
{
	local addr = opB1 + iD;
	*:1 addr = opC1:1;
}

:stw opC1, "["^opB1, iD^"]" is LOOP & (iI=0x2 & iST_Z=0x2 & iST_0=0) ... & opB1 ... & opC1 & iD ...
{
	local addr = opB1 + iD;
	*:2 addr = opC1:2;
}

#TODO: specification seems to be missing description of the size field
#TODO: Implement W vs. B version by constraining iC per datasheet p.123
#      and also sex instruction.
:ext opA1, opB1 is LOOP & (iI=0x3) ... & opA1 ... & opB1 ... & opC1 ...
{
	opA1 = zext(opB1:2); #zero extending word, see TODO above
	resultflags(opA1);
}

:b^COND^dd ADDR is LOOP & (iI=0x4) & COND & dd & ADDR
{
	build COND;
	build ADDR;
	goto ADDR;
}

:bl^COND^dd ADDR is LOOP & (iI=0x5) & COND & dd & ADDR
{
	build COND;
	build ADDR;
	blink = inst_next;
	call ADDR;
}

:lp^LP_COND^dd ADDR is PREV_ADDR & LOOP & (iI=0x6) & LP_COND & dd & ADDR
[
	# Set lp_in_use context variable for the last
	# instrution at the end of the loop so that
	# the end-of-loop check is performed only
	# in that instruction.
	# NOTE: if lp_end is overwritten while the
	# loop is running there will be sadness:'(
	lp_in_use=1;
	globalset(PREV_ADDR, lp_in_use);
	lp_in_use=0;
	globalset(ADDR, lp_in_use);
]
{
	build ADDR;
	lp_addr = ADDR;
	build LP_COND;
	lp_start = inst_next;
	lp_end = ADDR;
}

:j^COND^dd^FLAGS opB1 is LOOP & (COND & dd & FLAGS & iI=0x7 & iA=0 & iB=0x1F & iC=0) ... & opB1
{
	build COND;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	# TODO: not handling setting of E1 & E2 in the status register
	# 		see p. 95 of ARC Ref
	build FLAGS;
	return [blink];
}

:j^COND^dd^FLAGS JADDR is LOOP & COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB=62 & iC=0) ... & opB1 & JADDR
{
	build COND;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	goto [JADDR];
}

:j^COND^dd^FLAGS opB1 is LOOP & COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB<61 & iB!=0x1F & iC=0) ... & opB1
{
	build COND;
	addr = (opB1&0x0FFFFFF)<<2;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	goto [addr];
}

# TODO: implement correct jump address display for the rest of the j and jl constructors, the one below
# 	is (apparently) correct (or at least less wrong).
#TODO: implement correct loading of flag bits into blink when flag bit is set
# iB==62 => long immediate
:jl^COND^jl_dd^FLAGS JADDR is LOOP & COND ... & FLAGS ... & jl_dd ... & (iI=0x7 & iA=0 & iB=62 & iC=1) ... & opB1 & JADDR
{
	build COND;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	blink = inst_next;
	goto [JADDR];
}

:jl^COND^dd^FLAGS opB1 is LOOP & COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB<61 & iC=1) ... & opB1
{
	build COND;
	addr = (opB1&0x0FFFFFF)<<2;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	blink = inst_next;
	goto [addr];
}

:add^COND^FLAGS opA1, opB1, opC1 is LOOP & COND ... & FLAGS ... & iI=0x8 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 + opC1;
	local result = opA1;
	resultflags(result);
	addflags(opB1, opC1);
	# logicflags();
	build FLAGS;
	build LOOP;
}

:adc^COND^FLAGS opA1, opB1, opC1 is LOOP & COND ... & FLAGS ... & iI=0x9 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 + opC1 + zext(C);
	local result = opA1;
	resultflags(result);
	addflags(opB1, opC1);
	build FLAGS;
}

:sub^COND^FLAGS opA1, opB1, opC1 is LOOP & COND ... & FLAGS ... & iI=0xA ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 - opC1;
	local result = opA1;
	resultflags(result);
	subflags(opB1, opC1);
	build FLAGS;
}

:sbc^COND^FLAGS opA1, opB1, opC1 is LOOP & COND ... & FLAGS ... & iI=0xB ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 - opC1 - zext(C);
	local result = opA1;
	resultflags(result);
	subflags(opB1, opC1);
	build FLAGS;
}

:and^COND^FLAGSNZ opA1, opB1, opC1 is LOOP & COND ... & FLAGSNZ ... & iI=0xC ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 & opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

# with mov : iI = 0xC
# and reg, shimm, shimm
:mov^COND^FLAGSNZ opA1, opB1 is LOOP & COND ... & FLAGSNZ ... & (iI=0xC & (iB=61 | iB=63) & (iC=61 | iC=63)) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1; # & opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

# and reg, limm, limm
:mov^COND^FLAGSNZ opA1, opB1 is LOOP & COND ... & FLAGSNZ ... & (iI=0xC & iB=62 & iC=62) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1; # & opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

# and dst_reg, src_reg, src_reg
:mov^COND^FLAGSNZ opA1, opB1 is LOOP & COND ... & FLAGSNZ ... & (iI=0xC & iB=iC & iB<61 & iC<61) ... & opA1 ... & opB1& opC1
{
	build COND;
	opA1 = opB1; # & opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

# and shimm, op1, op1
:tst^COND^FLAGSNZ opB1 is LOOP & COND ... & FLAGSNZ ... & (iI=0xC & iA=63 & iB=iC & iB<61 & iC<61) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 & opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

:or^COND^FLAGSNZ opA1, opB1, opC1 is LOOP & COND ... & FLAGSNZ ... & iI=0xD ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 | opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

:xor^COND^FLAGSNZ opA1, opB1, opC1 is LOOP & COND ... & FLAGSNZ ... & iI=0xF ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 ^ opC1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}

# ROR p.119
:ror^COND^FLAGS opA1, opB1 is LOOP & COND ... & FLAGS ... & iI=0x3 ... & iB=iC ... & opA1 ... & opB1
{
	build COND;
	local tmp = (opB1 & 0x1);
	tmpC = tmp:1;
	opA1 = (opB1 >> 1) | (tmp << 31);
	local result = opA1;
	resultflags(result);
	tmpV = V;
	build FLAGS;
}

# ROR multiple p.120
:ror^COND^FLAGS opA1, opB1, opC1 is LOOP & COND ... & FLAGS ... & iI=0x13 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = (opB1 >> opC1) | (opB1 << (32-opC1));
	local result = opA1;
	resultflags(result);
	tmpV = V;
	tmpC = C;
	build FLAGS;
}

# ASL multiple p.84
:asl^COND^FLAGSNZ opA1, opB1, opC1 is LOOP & COND ... & FLAGSNZ ... & iI=0x10 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 << 1;
	local result = opA1;
	resultflags(result);
	build FLAGSNZ;
}


# ASL p.83
# NOTE: The specification has an _error_ where it claims that iI=0xC if there is no short immediate argumen.
# 	This conflicts with the definition of ADD, which has the same op code and is also contradicted
#	by the assembler.
:asl^COND^FLAGS opA1, opB1 is LOOP & COND ... & FLAGS ... & iI=0x8 ... & iB=iC ... & opA1 ... & opB1
{
	build COND;
	local tmp = (opB1 & 0x80000000) >> 31;
	tmpC = tmp:1;
	opA1 = opB1 << 1;
	local result = opA1;
	resultflags(result);
	tmpV = (tmpN != N);
	build FLAGS;
}

# TODO: implement correct semantics spec
:lsl^COND^FLAGS opA1, opB1, opC1 is LOOP & COND ... & FLAGS ... & iI=0x11 ... & iB=iC ... & opA1 ... & opB1 & opC1
{
	build COND;
	local tmp = (opB1 & 0x80000000) >> 31;
	tmpC = tmp:1;
	opA1 = opB1 << 1;
	local result = opA1;
	resultflags(result);
	tmpV = V;
	build FLAGS;
}

:nop^COND^FLAGS is LOOP & COND & FLAGS & iI=0xF & iA=63 & iB=63 & iC=63 & iD=0x1FF
{
}


# Nested delay slots at 0x00c0b5bc. Not quite identical to the code below but
# likely same issue.

# jl.jd xxxxxxx
# _mov xxxxx

# jl.z.jd xxxxxx   <---- horked here
# mov xxxxxx


# _jl.jd xxxxx
# __ld xxxxx