define token instr(32)
	iI    = (27, 31) # opcode
	iA    = (21, 26) # destination reg
	iBL_L = (7,26) signed  # destination address divided by 4
	iST_Di= (26, 26) # direct (cache bypass)
	iST_0 = (25, 25)
	iST_A = (24, 24) # address write-back enable
	iST_Z = (22, 23) # size field used by ST
	iA_alias  = (21, 26) # necessary because iA cannot occur as both parameter and constraint at once
	iB        = (15, 20) # op 1 address
	iB_alias  = (15, 20)
	iC        = (9, 14) # op 2 address
	iC_alias  = (9, 14)
	iLD0_R    = (13, 13) # reserved should be 0
	iLD1_R    = (6, 8)
	iLD0_Di   = (14, 14)  # direct (cache bypass)
	iLD1_Di   = (5, 5)
	iLD0_A    = (12, 12) # address write-back enable (see ARC Ref. p. 99)2
	iLD1_Z    = (1, 2)
	iLD0_Z    = (10, 11) # size field used by LD
	iLD0_X    = (9, 9)   # sign extend field
	iLD1_X    = (0, 0)
	iF   = (8, 8) # flags set field
	iR   = (7, 7) # reserved, must be 0
	iN   = (5, 6) # jump/call nullify instruction mode
	iQ   = (0, 4) # condition flags
	iD   = (0, 8); # short immediate data
define token limm_token(32)
       limm32_field = (0,31);

attach names iQ [
       AL EQ NE PL MI CS CC VS VC GT GE LT LE HI LS PNZ ex0
       ex1 ex2 ex3 ex4 ex5 ex6 ex7 ex8 ex9 exA exB exC exD exE exF
       ];

attach variables [ iA iB iC ] [
       r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14
       r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 fp sp
       ilink1 ilink2 blink
       ext0  ext1  ext2  ext3  ext4  ext5  ext6  ext7  ext8  ext9  ext10 ext11 ext12 ext13 ext14
       ext15 ext16 ext17 ext18 ext19 ext20 ext21 ext22 ext23 ext24 ext25 ext26 ext27 lp_count
       shimmflags limm shimmnoflags
];

# p.61 of ARC Ref. regs 61-63 reserved for encoding immediate data

# 61 - Short immediate data indicator setting
#      flags
# 62 - Long immediate data indicator
# 63 - Short immediate data indicator not setting
#      flags

# shimm9_A: "0" is iA { export *[const]:$(SIZE) iA; }
# shimm9:  ""^iD is iD { export *[const]:$(SIZE) iD; }
# limm32:  ""^limm32_field is limm32_field { export *[const]:$(SIZE) limm32_field; }

opA1: iA is iA_alias<61 & iA { export iA; } # normal register operand
opA1: "0" is iA_alias=61 & iA { export iA; } # short immediate with flags set
opA1: "0" is iA_alias>61 & iA { export iA; } # short immediate without flags set or long immediate flags?

opB1: iB is iB_alias<61 & iB { export iB; } # normal register operand
opB1: iD is iB=61 & iD { export *[const]:$(SIZE) iD; } # short immediate with flags set
opB1: iD is iB=63 & iD { export *[const]:$(SIZE) iD; } # short immediate without flags set
opB1: limm32_field is iB_alias=62 & iB_alias; limm32_field { export *[const]:$(SIZE) limm32_field; } # long immediate

opC1: iC is iC_alias<61 & iC { export iC; } # normal register operand
opC1: iD is iC=61 & iD { export *[const]:$(SIZE) iD; } # short immediate with flags set
opC1: iD is iC=63 & iD { export *[const]:$(SIZE) iD; } # short immediate without flags set
opC1: limm32_field is iC=62; limm32_field { export *[const]:$(SIZE) limm32_field; } # long immediate

cc: "" is iQ=0 { export 1:1; } #not displaying anything for always-execute
cc: ".eq" is iQ=1 { export Z; }
cc: ".ne" is iQ=2 { tmp:1 = !Z; export tmp; }
cc: ".pl" is iQ=3 { tmp:1 = !N; export tmp; }
cc: ".mi" is iQ=4 { export N; }
cc: ".cs" is iQ=5 { export C; }
cc: ".cc" is iQ=6 { tmp:1 = !C; export tmp; }
cc: ".vs" is iQ=7 { export V; }
cc: ".vc" is iQ=8 { tmp:1 = !V; export tmp; }
cc: ".gt" is iQ=9 { tmp:1 = (!Z) && (N==V); export tmp; }
cc: ".ge" is iQ=10 { tmp:1 = (N==V); export tmp; }
cc: ".lt" is iQ=11 { tmp:1 = (N!=V); export tmp; }
cc: ".le" is iQ=12 { tmp:1 = Z || (N!=V); export tmp; }
cc: ".hi" is iQ=13 { tmp:1 = C && (!Z); export tmp; }
cc: ".ls" is iQ=14 { tmp:1 = (!C) || Z; export tmp; }
cc: ".pnz" is iQ=15 { tmp:1 = (!Z) && (!N); export tmp; }

LOOP: "" is (lp_start & lp_end) { if (inst_next==lp_end) goto [lp_start]; }

COND: cc is cc & (iQ=0 & iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
COND: cc is cc & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { if (!cc) goto inst_next; }
# Always execute
COND: "" is ((iC > 60 & iC != 62) | (iB > 60 & iB != 62)) { } #(iC=61 | iC=63 | iB=61 | iB=63) { }

ADDR: reloc is iBL_L [ reloc = inst_next + (4*iBL_L); ] { export *[ram]:4 reloc; }

macro resultflags(result) {
 tmpN = result s< 0;
 tmpZ = result == 0;
}

macro addflags(op1,op2) {
 tmpC = carry(op1,op2);
 tmpV = scarry(op1,op2);
}

# NOTE:  unlike x86,  carry flag is SET if there is NO borrow
macro subflags(op1,op2) {
 tmpC = op2 <= op1;
 tmpV = sborrow(op1,op2);
}

# p.36 ARC4 CPU manual
macro loop() {
	if (inst_next!=lp_end) goto <skip>;
	lp_count = lp_count - 1;
	if (lp_count!=0) goto [lp_start];
	<skip>
}

FLAGS: ".f" is iF=1 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { C = tmpC; Z = tmpZ; N = tmpN; V = tmpV; }
FLAGS: ""   is iF=0 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
FLAGS: ".f" is (iC<63 & iB<63) { C = tmpC; Z = tmpZ; N = tmpN; V = tmpV; }
FLAGS: ""   is (iC=63 | iB=63) { }

FLAGSNZ: ".f" is iF=1 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { N = tmpN; Z = tmpZ; }
FLAGSNZ: ""   is iF=0 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
FLAGSNZ: ".f" is (iC<63 & iB<63) { N = tmpN; Z = tmpZ; }
FLAGSNZ: ""   is (iC=63 | iB=63) { }

# p. 93 of ARC Ref
# TODO: implement write-back and cache bypass and sign extend
:ld opA1, "["^opB1, opC1^"]" is (iI=0x0 & iLD1_Z=0x0 & iLD1_R=0x0) ... & opA1 ... & opB1 & opC1 ...
{
	local addr = opB1 + opC1;
	result = *:4 addr;
	#resultflags(result);
	opA1 = result;
}

:ldb opA1, "["^opB1, opC1^"]" is (iI=0x0 & iLD1_Z=0x1 & iLD1_R=0x0) ... & opA1 ... & opB1 & opC1 ...
{
	local addr = opB1 + opC1;
	result = *:1 addr;
	#resultflags(result);
	opA1 = zext(result);
}

:ldw opA1, "["^opB1, opC1^"]" is (iI=0x0 & iLD1_Z=0x2 & iLD1_R=0x0)  ... & opA1 ... & opB1 & opC1 ...
{
	local addr = opB1 + opC1;
	result = *:2 addr;
	#resultflags(result);
	opA1 = zext(result);
}

:ld opA1, "["^opB1, iD^"]" is (iI=0x1 & iLD0_Z=0x0 & iLD0_R=0) ... & opA1 ... & opB1 & iD ...
{
	local addr = opB1 + iD;
	result = *:4 addr;
	#resultflags(result);
	opA1 = result;
}

:ldb opA1, "["^opB1, iD^"]" is (iI=0x1 & iLD0_Z=0x1 & iLD0_R=0) ... & opA1 ... & opB1 & iD ...
{
	local addr = opB1 + iD;
	result = *:1 addr;
	#resultflags(result);
	opA1 = zext(result);
}

:ldw opA1, "["^opB1, iD^"]" is (iI=0x1 & iLD0_Z=0x2 & iLD0_R=0)  ... & opA1 ... & opB1 & iD ...
{
	local addr = opB1 + iD;
	result = *:2 addr;
	#resultflags(result);
	opA1 = zext(result);
}

# TODO: flags?
:lr opA1, "["^opB1^"]" is (iI=0x1 & iLD0_Z=0x0 & iLD0_R=1 & iB!=62) ... & opA1 ... & opB1 & iD ...
{
	local addr = 0x1200 + opB1:2;
	result = *[register] addr;
	#resultflags(result);
	opA1 = result;
}

:st opC1, "["^opB1, iD^"]" is (iI=0x2 & iST_Z=0x0 & iST_0=0) ... & opB1 ... & opC1 & iD ...
{
	local addr = opB1 + iD;
	*:4 addr = opC1;
	resultflags(opC1);
}

:stb opC1, "["^opB1, iD^"]" is (iI=0x2  & iST_Z=0x1 & iST_0=0)... & opB1 ... & opC1 & iD ...
{
	local addr = opB1 + iD;
	*:1 addr = opC1;
	resultflags(opC1);
}

:stw opC1, "["^opB1, iD^"]" is (iI=0x2 & iST_Z=0x2 & iST_0=0) ... & opB1 ... & opC1 & iD ...
{
	local addr = opB1 + iD;
	*:2 addr = opC1;
	resultflags(opC1);
}

#TODO: specification seems to be missing description of the size field
:ext opA1, opB1 is (iI=0x3) ... & opA1 ... & opB1 ... & opC1 ...
{
	opA1 = zext(opB1:2); #zero extending word, see TODO above
	resultflags(opA1);
}

:b^COND^dd ADDR is (iI=0x4) & COND & dd & ADDR
{
	build COND;
	build ADDR;
	goto ADDR;
}

:bl^COND^dd ADDR is (iI=0x5) & COND & dd & ADDR
{
	build COND;
	build ADDR;
	blink = inst_next;
	call ADDR;
}

:j^COND^dd^" blink" is COND & dd & iI=0x7 & iA=0 & iB=0x1F & iC=0 & iF=0 #not handling set flags see instruction manual
{
	return [pc];
}

:j^COND^FLAGS opB1 is COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB=62 & iC=0) ... & opB1
{
	build COND;
	addr = opB1&0x0FFFFFFF<<2;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	goto [opB1];
}

:j^COND^dd^FLAGS opB1 is COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB!=62 & iC=0) ... & opB1
{
	build COND;
	addr = opB1&0x0FFFFFFF<<2;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	goto [addr];
}

#TODO: implement correct loading of flag bits into blink when flag bit is set
:jl^COND^FLAGS opB1 is COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB=62 & iC=1) ... & opB1
{
	build COND;
	addr = opB1&0x0FFFFFFF<<2;
	blink = inst_next;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	goto [opB1];
}

#TODO: implement correct loading of flag bits into blink when flag bit is set
:jl^COND^dd^FLAGS opB1 is COND ... & FLAGS ... & dd ... & (iI=0x7 & iA=0 & iB!=62 & iC=1) ... & opB1
{
	build COND;
	addr = opB1&0x0FFFFFFF<<2;
	blink = inst_next;
	tmpZ = opB1[31,1];
	tmpN = opB1[30,1];
	tmpC = opB1[29,1];
	tmpV = opB1[28,1];
	build FLAGS;
	goto [addr];
}

:add^COND^FLAGS opA1, opB1, opC1 is COND ... & FLAGS ... & iI=0x8 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 + opC1;
	local result = opA1;
	resultflags(result);
	addflags(opB1, opC1);
	# logicflags();
	build FLAGS;
}

:adc^COND^FLAGS opA1, opB1, opC1 is COND ... & FLAGS ... & iI=0x9 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 + opC1 + zext(C);
	local result = opA1;
	resultflags(result);
	addflags(opB1, opC1);
	# logicflags();
	build FLAGS;
}

:sub^COND^FLAGS opA1, opB1, opC1 is COND ... & FLAGS ... & iI=0xA ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 - opC1;
	local result = opA1;
	resultflags(result);
	subflags(opB1, opC1);
	build FLAGS;
}

:sbc^COND^FLAGS opA1, opB1, opC1 is COND ... & FLAGS ... & iI=0xB ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 - opC1 - zext(C);
	local result = opA1;
	resultflags(result);
	subflags(opB1, opC1);
	build FLAGS;
}

:and^COND^FLAGSNZ opA1, opB1, opC1 is COND ... & FLAGSNZ ... & iI=0xC ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 & opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

# and reg, shimm, shimm
:mov^COND^FLAGSNZ opA1, opB1 is COND ... & FLAGSNZ ... & (iI=0xC & (iB=61 | iB=63) & (iC=61 | iC=63)) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1; # & opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

# and reg, limm, limm
:mov^COND^FLAGSNZ opA1, opB1 is COND ... & FLAGSNZ ... & (iI=0xC & iB=62 & iC=62) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1; # & opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

# and dst_reg, src_reg, src_reg
:mov^COND^FLAGSNZ opA1, opB1 is COND ... & FLAGSNZ ... & (iI=0xC & iB=iC & iB<61 & iC<61) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1; # & opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

# and shimm, op1, op1
:tst^COND^FLAGSNZ opB1 is COND ... & FLAGSNZ ... & (iI=0xC & iA=63 & iB=iC & iB<61 & iC<61) ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 & opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

:or^COND^FLAGSNZ opA1, opB1, opC1 is COND ... & FLAGSNZ ... & iI=0xD ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 | opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

:xor^COND^FLAGSNZ opA1, opB1, opC1 is COND ... & FLAGSNZ ... & iI=0xF ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 ^ opC1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

:asl^COND^FLAGSNZ opA1, opB1, opC1 is COND ... & FLAGSNZ ... & iI=0x10 ... & iB=iC ... & opA1 ... & opB1 & opC1
{
	build COND;
	local tmp = (opB1 & 0x80000000) >> 31;
	tmpC = tmp:1;
	opA1 = opB1 << 1;
	local result = opA1;
	resultflags(result);
	#build FLAGSNZ;
}

# TODO: implement correct semantics spec
:lsl^COND^FLAGSNZ opA1, opB1, opC1 is COND ... & FLAGSNZ ... & iI=0x11 ... & iB=iC ... & opA1 ... & opB1 & opC1
{
	build COND;
	local tmp = (opB1 & 0x80000000) >> 31;
	tmpC = tmp:1;
	opA1 = opB1 << 1;
	local result = opA1;
	resultflags(result);
	# build FLAGSNZ;
}

:nop^COND^FLAGS is COND & FLAGS & iI=0xF & iA=63 & iB=63 & iC=63 & iD=0x1FF
{
}