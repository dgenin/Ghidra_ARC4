define token instr(32)
	iI   = (27, 31) # opcode
	iA   = (21, 26) # destination reg
	iA_alias = (21, 26)
	iB   = (15, 20) # op 1 address
	iB_alias = (15, 20)
	iC   = (9, 14) # op 2 address
	iC_alias   = (9, 14)
	iF   = (8, 8) # flags set field
	iR   = (7, 7) # reserved, must be 0
	iN   = (5, 6) # jump/call nullify instruction mode
	iQ   = (0, 4) # condition flags
	iD   = (0, 8); # short immediate data
define token limm_token(32)
       limm32_field = (0,31);

attach names iQ [
       AL EQ NE PL MI CS CC VS VC GT GE LT LE HI LS PNZ ex0
       ex1 ex2 ex3 ex4 ex5 ex6 ex7 ex8 ex9 exA exB exC exD exE exF
       ];

attach variables [ iA iB iC ] [
       r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14
       r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 fp sp
       ilink1 ilink2 blink
       ext0  ext1  ext2  ext3  ext4  ext5  ext6  ext7  ext8  ext9  ext10 ext11 ext12 ext13 ext14
       ext15 ext16 ext17 ext18 ext19 ext20 ext21 ext22 ext23 ext24 ext25 ext26 ext27 lp_count
       shimmflags limm shimmnoflags
];

# p.61 of ARC Ref. regs 61-63 reserved for encoding immediate data

# 61 - Short immediate data indicator setting
#      flags
# 62 - Long immediate data indicator
# 63 - Short immediate data indicator not setting
#      flags

shimm9_A: "0" is iA { export *[const]:$(SIZE) iA; }
shimm9:  ""^iD is iD { export *[const]:$(SIZE) iD; }
limm32:  ""^limm32_field is limm32_field { export *[const]:$(SIZE) limm32_field; }

#allimmediate:   is iA=60 & iB<61 & iC<61 {}
#allimmediate:   is iA=62 & iB<61 & iC<61 & limm32_field { tmp=limm32_field; }

opA1: iA is iA_alias<61 & iA {export iA; } # normal register operand
opA1: "0" is iA_alias=61 & iA {export iA; } # short immediate with flags set
opA1: "0" is iA_alias>61 & iA {export iA; } # short immediate without flags set or long immediate flags?

opB1: iB is iB_alias<61 & iB {export iB; } # normal register operand
opB1: iD is iB=61 & iD {export *[const]:$(SIZE) iD; } # short immediate with flags set
opB1: iD is iB=63 & iD {export *[const]:$(SIZE) iD; } # short immediate without flags set
opB1: limm32_field is iB_alias=62 & iB_alias; limm32_field {export *[const]:$(SIZE) limm32_field; } # long immediate

opC1: iC is iC_alias<61 & iC {export iC; } # normal register operand
opC1: iD is iC=61 & iD {export *[const]:$(SIZE) iD; } # short immediate with flags set
opC1: iD is iC=63 & iD {export *[const]:$(SIZE) iD; } # short immediate without flags set
opC1: limm32_field is iC=62; limm32_field {export *[const]:$(SIZE) limm32_field; } # long immediate

cc: ".AL" is iQ=0 { export 1:1; }
cc: ".EQ" is iQ=1 { export Z; }
cc: ".NE" is iQ=2 { tmp:1 = !Z; export tmp; }
cc: ".PL" is iQ=3 { tmp:1 = !N; export tmp; }
cc: ".MI" is iQ=4 { export N; }
cc: ".CS" is iQ=5 { export C; }
cc: ".CC" is iQ=6 { tmp:1 = !C; export tmp; }
cc: ".VS" is iQ=7 { export V; }
cc: ".VC" is iQ=8 { tmp:1 = !V; export tmp; }
cc: ".GT" is iQ=9 { tmp:1 = (!Z) && (N==V); export tmp; }
cc: ".GE" is iQ=10 { tmp:1 = (N==V); export tmp; }
cc: ".LT" is iQ=11 { tmp:1 = (N!=V); export tmp; }
cc: ".LE" is iQ=12 { tmp:1 = Z || (N!=V); export tmp; }
cc: ".HI" is iQ=13 { tmp:1 = C && (!Z); export tmp; }
cc: ".LS" is iQ=14 { tmp:1 = (!C) || Z; export tmp; }
cc: ".PNZ" is iQ=15 { tmp:1 = (!Z) && (!N); export tmp; }

COND: cc is cc & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { if (!cc) goto inst_next; }
# Always execute
COND: "" is (iC=61 | iC=63 | iB=61 | iB=63) { }

FLAGS: ".F" is iF=1 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
FLAGS: ""   is iF=0 & (iC!=61 & iC!=63 & iB!=61 & iB!=63) { }
FLAGS: ""   is (iC=61 | iC=63 | iB=61 | iB=63) { }

macro subflags(op1,op2) {
 tmpC = op2 <= op1;
 tmpV = sborrow(op1,op2);
}

# macro logicflags() {
#   tmpCY = shift_carry;
#   tmpOV = OV;
# }

macro resultflags(result) {
 tmpN = result s< 0;
 tmpZ = result == 0;
}

# p. 93 of ARC Ref
#iA_flags: iA^".f" is iA
# :add.f shimm9_A, iB, i	C is iI=0x8 & iA>60 & iF=1 & shimm9_A & iB & iC { }
# :add   shimm9_A, iB, iC is iI=0x8 & iA>60 & iF=0 & shimm9_A & iB & iC { }
# :add   iA, iB, limm32 is iI=0x8 & iC=62 & iA & iB; limm32 { }
# :add   iA, iB, shimm9 is iI=0x8 & iC=63 & iA & iB & shimm9 { }
# :add.f  iA, iB, shimm9 is iI=0x8 & iC=61 & iA & iB & shimm9 { }
# :add   iA, iB, iC is iI=0x8 & iA & iB & iC { }

# :add opA1, iB, iC is iI=0x8 & opA1 & iB & iC
# {
# }

:add^COND^FLAGS opA1, opB1, opC1 is COND ... & FLAGS ... & iI=0x8 ... & opA1 ... & opB1 & opC1
{
	build COND;
	opA1 = opB1 + opC1;
	#teh_result = opA1;
	#build FLAGS;
}

:sub^COND^FLAGS  opA1, opB1, opC1 is COND ... & FLAGS ... & iI=0xA ... & opA1 ... & opB1 & opC1
{
}
